6.945 Final Project: Match Definitions and Cases in MIT Scheme

By Tom Boning, Eli Davis, and Jenny Ramseyer

Project Github: https://github.com/orinatic/Match-Define

Our project aims to implement case matching and match definitions in
MIT Scheme.  Currently we support match definitions in Scheme.  We aim
to have pattern matching working by our presentation on Wednesday.  

By match definitions, we mean allowing definitions (and let,
named-let, let*, and letrec) of the form 
(define '(a b c) '(1 2 3))
to set a = 1, b = 2, and c = 3

We also support match statements of the form written in pset 4, where
we can do 
(let* ((*run-matcher* '((? x) (? y)) '((1 2)))
     (c x))
     body) ;where body is the body of the let* expression

;*run-match* runs the matcher from pset 4.  

Unfortunately, it currently does not work.  We have some known bugs,
which we plan to ask Professor Sussman and Lars on Monday.  

Our attempt went as follows. We wrote macros for define, let, let*,
letrec, and named-let which all work correctly.  Define can define
things at the correct scope level, depending where it is in a
function, and the lets are all scoped correctly.  The code for these
macros is in "working-functions.scm" (attached).  These macros work
fine, given the output of a call to *run-matcher* (an alist), an
ordinary function statement (ie, the ordinary syntax of a let, let*,
define, etc), or some combination of the two, along with a body.
Calls to these functions are identical to a call to the ordinary
version of the function, except that the function name is different.  

Unfortunately, there's a key bug in these macro definitions.  When we
 evaluate match in a macro, we don't have access to the
environment, so we don't catch other existing bindings in the
environment.  So sometimes our matches fail when they shouldn't.  We
should ask Professor Sussman about this on Monday.  This may be
avoidable for let, but will be much trickier (if possible?) for
define.  Another consequence of that is that we can't do expressions
 like the following:

(define p '((? a) (? b)))

(match-define p '((4 2)))

Instead of substituting in the value of p that p is defined to be,
match-define will use the symbol "p".  Our macros can't access things
that were defined elsewhere in the environment.  Sometimes it works
out, in the case where when we eval the output of our macro and the
repl then looks up the value, as in this case:

(define d 4)
(match-define '((? a) (? b)) '((1 d)))
will succeed and output a = 1 and b = 4.  But really, what the macro
has done is set b = d, which when evaluated, the repl later decides is
b = 4.  But this doesn't work in all cases.  It just happens to work
here because we need to do anything with b that relies on b = 4, (as
opposed to b = someFunction) so it silently succeeds.  If we tried to
do 

(define dict ((a b c) (1 2 3))
(match-let dict
  (pp 1))
it will break (note that it will break because it can't look up the
value of dict within our match-let macro.  Contrary to appearances, it
won't break because it's trying to be a named-let, because we have our
own version of match-named-let which we use instead).  

This is inconvenient, but leads to a larger problem: Case matching
doesn't work.  In order to case match, we need to be able to calls
like
(define foo '(bin-op + 1 2))
(match-case foo
    (('binop (? op) (? a) (? b))
       (eval op a b env))
    (('binop-debug (? op) (? a) (? b))
       (pp op a b)))

But match-case will require using our definitions of match-let, which can't
access the definition of foo, so it all breaks.  



